# Cursor Rules for Neighbor Project

## Project Context
- This is a Nuxt.js 4 project using TypeScript
- Uses Nuxt UI for components
- Package manager: pnpm (use `pnpm` commands, not npm/yarn)
- Uses ESLint with @nuxt/eslint

## Code Style

### TypeScript/Vue
- Use TypeScript strictly - avoid `any` types when possible
- Use Vue 3 Composition API with `<script setup>` syntax
- Prefer `defineProps`, `defineEmits`, `defineExpose` macros
- Use `ref`, `computed`, `watch`, `onMounted` from Vue

### Formatting
- No trailing commas (comma dangle: 'never')
- Use 1tbs brace style (opening brace on same line)
- Use 2 spaces for indentation
- Use single quotes for strings unless double quotes are needed
- Prefer const over let, avoid var

### File Organization
- Use Nuxt's auto-imports - don't manually import composables like `useState`, `useFetch`, `navigateTo`, etc.
- Place components in `components/` directory (auto-imported)
- Place composables in `composables/` directory (auto-imported)
- Place utilities in `utils/` directory
- Use `server/` directory for API routes and server utilities
- Use `types/` directory for TypeScript type definitions

## Nuxt-Specific Guidelines

### Routing
- Use file-based routing in `pages/` directory
- Use `navigateTo()` for programmatic navigation
- Use `<NuxtLink>` for internal links

### Data Fetching
- Prefer `useFetch` or `useAsyncData` for data fetching
- Use `$fetch` for API calls in composables
- Leverage Nuxt's built-in caching and reactivity

### State Management
- Use `useState` for client-side reactive state
- Use `useCookie` for cookie management
- Consider Pinia for complex state management if needed

### Server-Side
- Use `server/api/` for API endpoints
- Use `server/utils/` for server-only utilities
- Use `server/middleware/` for middleware

## Component Guidelines

### Component Structure
```vue
<script setup lang="ts">
// Imports
// Props/Emits definitions
// Composables
// State
// Computed
// Methods
// Lifecycle hooks
</script>

<template>
  <!-- Template content -->
</template>

<style scoped>
/* Component styles */
</style>
```

### Nuxt UI Components
- Prefer Nuxt UI components when available
- Use Iconify icons via `@iconify-json/lucide` and `@iconify-json/simple-icons`
- Follow Nuxt UI design patterns

## Best Practices

### Performance
- Use `lazy` prop for components that aren't immediately needed
- Use `v-show` for frequent toggles, `v-if` for conditional rendering
- Optimize images using Nuxt Image if needed
- Leverage Nuxt's automatic code splitting

### Accessibility
- Use semantic HTML
- Include proper ARIA labels when needed
- Ensure keyboard navigation works
- Test with screen readers when possible

### Error Handling
- Use Nuxt's error handling (`showError`, `clearError`)
- Handle loading and error states in data fetching
- Provide meaningful error messages

### Testing
- Write tests for critical functionality
- Test composables independently
- Test components in isolation

## Commands
- `pnpm dev` - Start development server
- `pnpm build` - Build for production
- `pnpm preview` - Preview production build
- `pnpm lint` - Run ESLint
- `pnpm typecheck` - Run TypeScript type checking

## When Making Changes
- Always run `pnpm lint` and `pnpm typecheck` before committing
- Follow existing code patterns and conventions
- Keep components small and focused
- Extract reusable logic into composables
- Write self-documenting code with clear variable names
- Add comments for complex logic, but prefer clear code over comments

## Avoid
- Don't use `process.env` directly - use `useRuntimeConfig()` or `useAppConfig()`
- Don't manually import auto-imported Nuxt composables
- Don't use `@/` alias - Nuxt handles imports automatically
- Don't create unnecessary abstractions
- Don't ignore TypeScript errors

